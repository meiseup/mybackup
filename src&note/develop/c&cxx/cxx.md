C++_Base

c++基础语法:
        命名空间namespace
//!主函数不能定义在命名空间中....,命名空间的定义是可选的，命名空间定义语法:
namespace <..名>{
....
class <..名>{
//访问修饰赋
<private/public/protected>:
    类成员定义....
    };
};

        类class
使用命名空间std中的cout对象
using std::cout;
cout,cin,endl等对象在头文件iostream中的std命名空间中声明,使用它们之前需要先导入头文件iostream，但c++在导入它们的头文件时却没有后缀.
还要使用using namespace引用命名空间的所有对象，如果没有显式引用命名空间，那么在使用这些对象时需要添加作用域限定前缀.
#include <iostream>
using namespace std;

/*
如果只是要引入命名空间的少数对象，作用域限定符是命名空间名或者类名紧跟两个冒号.作用域限定与对象之间没有分隔符.*/ 语法：
using <作用域限定><对象名>;
using std::cout;

        引用&

        类的构造和析构函数
/*
在c++中，类(结构体)中不仅可以像C的结构体那样定义成员，还可以定义函数.
类的构造函数一般用来初始化类成员，而类的析够函数作用与类的构造函数作用是相反的.
*/
....
class Class{
<public>|<private>|<protected>:
//为一个指针成员分配堆上的内存地址空间使用new关键字.
int *x = new int;
//还可以在分配内存的时候初始化.
int *x = new int(3);

/*
在一个定义好的类中，默认存在一个无参构造和一个this指针，但如果自己定义了有参的构造，那么就应该也提供一个无参的构造。
*/

/*这个this指针是指向类自身的，如果构造函数的形参名和类中的某个成员名相同，那么就需要使用this指针来引用类成员，否则编译器就无法识别这个函数是函数的参数还是类中的某个成员.
*/
int a;
    Class(){}
    Class(int a){
         this->a = a;
    }
    Class (int a,char b){}
/*
 同名函数是c++的新的特性，它属于函数的重载(overload),它要求函数名称相同，而函数的形参不同,但构造函数不能有返回值关键字.
  */

    ~Class(){}
};
....

访问权限access:
结构体成员默认的访问权限是public,也就是所有其它对象都可以访问.

类成员默认访问权限是private，除了类自己和类自己的成员，谁也无法访问.

protected访问权限除了类和类的派生类(子类)之外，所有其它的类或者类成员无法去试图访问.

类还可以和C一样将声明放在一个单独的文件中，然后在c++源文件中引入.

返回值类型 <作用域><函数名和参数>{}
void person::show(){...}

c++运算符:
//作用域符号之前是一个命名空间名称或者类名(包括结构体)
:: 作用域限定符是紧挨在一起的冒号,一般为了引用某个命名空间或者类中的成员时使用;
person::show();

>>/<< 标准输入/输出对象,cout/cin
cout << "";
cin >> i;

& 如果是在作为定义或者声明一个变量的时候被使用，它不再作为取地址和逻辑与运算符，而是一种引用.
int &a = ;
int swap(&a,&b){}

 vim:set filetype=markdown: 

？如果一个实现类在实例化对象时使用了匿名对象，那么除了父类或者接口中的方法外，能否访问自身的方法
经过测试，发现匿名对象同样可以调用自身的成员,匿名对象并没有实现多态。
？jdbc能否通过windows验证的方式连接到SQL Server数据库
这是一种并不推荐的连接方式，建议只做测试使用
1.根据系统的字长，添加对应的sqljdbc_auth.dll动态连接库到系统的system32目录下
2.定义SQL Server数据库连接字符串中时需要将windows集成安全验证IntegratedSecurity设为true，参数用户名和密码省略
加载类
Class.forName("com....SQLServerDriver");
* 如果使用默认端口号，则在连接字符串中可省略端口号
* windows集成安全选项必须设为true;
 -> String url="jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=;Integrated Security=true"
 ..
 con = DriverManager.getConnection(url); //不再指定用户名和密码
 ...
 经过以上的步骤，理论上说就可以实现jdbc使用windows验证方式连接数据库了
？ 为什么要使用多态，面向接口编程？
   List list = new ArrayList();
   List list = new LinkedList();
   List list = new Vectory();
 ？List只是一个接口，为什么可以用来声明一个对象
  声明一个
 * 这里的list只是编译时的类型，当编译器实例化对象完成后会将它转换成new的数据类型，但是这种方式声明的对象只能对接口中的方法进行重写。无法调用自身特有的方法
* 将接口的实现类声明为接口或者将将抽象类的继承类声明为它的抽象父类。这种方式实现了多态。
* 编译时类型为声明类型，即:接口或者抽象父类；运行时则会将它转换为new的类型
* 不使用接口或者抽象类来声明接口实现类或者继承类，这并不是一种被推荐的做法。因为这并没有使用Java面向对象语言中的多态思想。
* 这种方式实例化的对象并没有语法错误。如果要调用实现类自身的方法，则需要使用它new的时候使用的数据类型;这里，也可以使用匿名对象来调用。
  > ArrayList list = new ArrayList();
  > LinkedList list = new LinkedList();
  > HashMap hmmp = new HashMap(String key,String value);
 * 通过这种方式new的对象，除了可以对所继承的接口中的抽象方法进行重写，还可以调用自身的方法。但是这并不方便代码后期的维护。

* 存在一种方式可以让接口被实例化，它必须作为类的内部类来使用,并且要实现接口中所定义的方法。语法:
接口名 标识符 = new 接口(){......实现接口中的方法.....};
抽象类 标识符 = new 抽象类(){......实现抽象方法......};

2015/11/20 星期五
？多态的表现形式
* 通过抽象父类搞出很多子类对象，执行的方法却是子类对象已经重写过的方法;调用的方法都是父类的方法
* 通过抽象父类或者接口创建的子类或者接口实现类对象只能选择重写父类中的方法，如果试图调用子类中存在的而父类中不存在的方法，那么将会发生编译错误。如果确实要调用子类自身的方法，则不能使用父类创建子类对象即不使用多态思想。还可以使用匿名对象来调用
使用父类创建子类对象
使用接口创建接口实现类对象、
使用抽象类创建实现抽象类的子类对象(一般通过子类继承抽象类，重写抽象父类中的所有抽象方法，否则子类也只能是抽象类)

？遍历一个集合中的元素
* 如果集合中添加的只是基本类型数据，那么从一个集合中得到所添加的数据只需要对这个集合进行遍历即可得到值
通过集合的get方法和索引即可得到
可以使用基本的for循环，也可以使用foreach循环
for(int i = 0;i<集合名.size();i++){
 get(i); //取出数据，引用类型转换为值(术语:拆箱)需要经过强制类型转换
}
* 如果在定义集合时使用了泛型，或者集合中保存的是一个数组对象，那么使用foreach循环来遍历集合或者泛型集合显然更方便。
for(集合中存储的数据类型 变量名 : 集合名){
  // 不需要强制类型转换(拆箱的过程)
}
？如果集合中存储的不是基本数据类型,而是一个自定义数据类型的对象呢，如何访问对象的属性和方法或者其它的成员
* 同样只需要遍历集合就行了，只是这里进行遍历的，是集合中存储的对象了；通过访问对象的属性
 如果已经将属性封装，则需要通过调用对象属性所对应的set方法为对象的属性进行赋值同样；
 通过属性对应的get方法即可得到属性的值
* 使用foreach循环来遍历集合中存储的对象，还可以通过集合遍历器Itator来遍历集合。
for(集合中存储的对象的类型 对象名 : 集合名){
  对象名.属性名();或者
  对象名.getxxx();
}
？结果集对象调用getXXX()试图读取某列数据时被JVM提示列名无效
首先应该检查表名以及列名是否正确，如果都确认无误，则继续检查是否将结果集getXXX()要读取的列包含在sql语句查询的列中
* 如果查询语句中没有包含某些列的列名，则通过结果集对象的getXXX()将不能读取这些列的数据
* 结果集对象只能读取sql语句中要查询的列的数据
假设存在一个users表，表中有两个字段，name和pwd
select name from users; //只查询name
....
rs.getX("pwd"); //如果试图调用结果集对象的getX()方法读取pwd字段的值将会无法读取pwd字段的值，JVM将返回列名无效的错误
？静态代码块中的变量和静态变量到底谁先被执行
按照关键字静态的static的定义，会按照顺序对成员访问，静态代码块无法访问类属性即在类中定义的类变量
？接口定义
* 接口中定义声明的变量都必须是公共的、终态的、静态的(即使在接口中定义变量时省略)，调用时无法再被重新赋值
每个变量都要以接口名.变量名来调用
* 接口中的方法都必须是抽象方法。不能有方法体。如果一个子类想要实现它，则必须重写接口中的所有方法
* 接口中的变量不能使用private修饰，方法不能使用static和final修饰，也不能用private修饰
？使用IO流来读取或者向文件中写入信息
* 流的读取和关闭均为检查异常，必须显式try-catch
* 流的读取或者写入之后总是需要被关闭，如果不关闭流，虽然编译运行不会出错，但可能得不到所需要的结果
？如果在一个类中不存在无参构造，则在实例化类对象时必须调用其有参构造来完成对象的实例化，否则会出现编译错误
？如果Java代码块声明了异常却又在方法中抛出异常，
以下代码
.....throws NullPointerException(){
....
throw new Excpetion();
...
}
？Web项目修改了项目名称后，在部署时使用原来的路径
选中项目右键，打开项目属性，搜索web
修改Context...为新的路径

修改了Java代码不重启Tomcat的方法：
Jsp代码修改之后不需要重启Tomcat  
以正常方式启动的Tomcat在修改了Java代码后需要重新部署和重启Tomcat服务  
如果将Tomcat以Debug的方式启动，修改Java代码之后Tomcat会自动重新载入，只限普通Java代码  
如果改了方法定义(方法形参变动，方法名改动等则需要重新部署项目，并重启Tomcat)
  
调试Servlet或者jsp中的小脚本方法：  
应用服务器(如Weblogic,apache Tomcat)应该以Debug方式启动
jsp或者Servlet中需要设置了断点
vim:set ft=markdown:
